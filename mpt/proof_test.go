/*
 * Copyright (C) 2021 Zilliqa
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */
package mpt

import (
	"github.com/Zilliqa/gozilliqa-sdk/core"
	"github.com/Zilliqa/gozilliqa-sdk/util"
	"strings"
	"testing"
)

func TestVerify(t *testing.T) {
	// key is contract address
	contractAddress := "8b6cd9c2947a87eddf40dc3cbe87146d262a98d3"
	key := []byte(contractAddress)

	// account proof
	proofString := []string{
		"E216A0CF58913C0B76308159D74970E5ED79996558BECBE7AAECE2B86A07A921601F2B",
		"F851808080A08E0B078618F73E4137A0F3614EED4796DE04B8EA91E05CF0F16EC882A2AF3ACA8080A0B76F9109E48C6FEB74574568424C3E6E213C0DFAA2818CF5163695363B13837180808080808080808080",
		"F8718080A0CCEFD7327574F7A273C729EC27A1E75BA49BEE0603AF9C9323434B0F3DB4763F80A0EDCC7D2D7246226CC70657B0D330719EB4C1D773DBD07A24B94A0C11A052805680A06338974228CC65B824DB52C1A4D419EE2363BFBBAD64BB1BE2C1DB0EF870E5D980808080808080808080",
		"F886A7203663643963323934376138376564646634306463336362653837313436643236326139386433B85C080112120A100000000000000000000000000000000018002220CF5C8F0ED67823CBD9026E3AE269D96694FAB5CA3C1E42F815DAB00C4EC019502A20E310F03EA31586F9EE19914F0CCA84A3143B06D5ABD9021304C1499E473DDAF6",
		"F90111A0DE0385E820063760D932A457B2697B23F060E06D189DA77D092E351A436027EFA0756DFFE7AD25E0F88EE51EFAC9E49754CBE37E7A5C3294D47CDD0A16ADC2271D80A030038C97B734C606616697E977011674EE5E8B6D42C1C6F75A1B89D233CD016BA07D824C36456A0441CF34B19A4C5B12DCF65C94599B3CEA1687045AF14D7C7DABA0BAF11F757340F98F6A4379F81CE789446E6A591464435CA555D1ACEAE17DE9ECA005417A2FAFC580D5F71C84665A4359E431BCF30AC86BB0CFE75968ECDF5EDA00A008E4B11103F53219B4DC9D5E04EB662445848722030C6DCD168E8474369CC18FA0900FC09D652AB490DE1B56E498D034260DC470C14BC545D630021285598C5E308080808080808080",
	}
	var proof [][]byte

	for _, p := range proofString {
		bytes := util.DecodeHex(p)
		proof = append(proof, bytes)
	}

	db := NewFromProof(proof)

	// StateRootHash from tx block
	root := util.DecodeHex("fd80db4cd1654bef7cf2d5abb9be7e29556279812fc524a26982a519d80bf4ec")
	value, err1 := Verify(key, db, root)
	if err1 != nil {
		t.Fatal(err1.Error())
	}
	t.Log(util.EncodeHex(value))

	storageKey := core.GenerateStorageKey(contractAddress, "zilToPolyTxHashMap", []string{"0"})
	hashedStorageKey := util.Sha256(storageKey)
	t.Log("hashed storage key is: " + util.EncodeHex(hashedStorageKey))

	//hashedStorageKey := "B65F9D0A42C98311E59384B6643C2EFF7F7E12D65873C156ED0D2C4D7C43C4F5"
	//key3 := []byte(storageKey)
	key3 := []byte(strings.ToUpper(util.EncodeHex(hashedStorageKey)))

	// state proof
	proofString3 := []string{
		"F851808080A0B13790A0102FB48239F59CADBC1485B53747232D8DC8BE87561554C6901B0E24A08C1BB1176DF022E006740DEA16A56E35657C038FCBCECF09952F83D88718B056808080808080808080808080",
		"F888B84020363546394430413432433938333131453539333834423636343343324546463746374531324436353837334331353645443044324334443743343343344635B8442230783238343537366362316336613933306630326462363733633630343131613431653331363832333634393934643962363837626532613164326533616532613722",
		"F8B18080A0B27A7075ADEF3250CE63FA792A3180BF2985DADEB04CDF43D924BEAEF17FBCF7A0CD3A9638AF1BBF879BCC296B0540027C4EAC9C8975D420903CDE03DEF75319D6A0FDE42B2665E37D6982706A79877D8EA95C476C6CB66B4237930AF9189B55130BA095280A633AADBF21829BD1AB7BF67A753CC19146CFB74FFE3CC4C63D29609C90A058BD69A980FABA76F395A0834B790A52665E44028A5325658686B05BEC60D55780808080808080808080",
	}
	var proof3 [][]byte

	for _, p := range proofString3 {
		bytes := util.DecodeHex(p)
		proof3 = append(proof3, bytes)
	}

	db3 := NewFromProof(proof3)

	accountBase, _ := core.AccountBaseFromBytes(util.DecodeHex("080112120a100000000000000000000000000000000018002220cf5c8f0ed67823cbd9026e3ae269d96694fab5ca3c1e42f815dab00c4ec019502a20e310f03ea31586f9ee19914f0cca84a3143b06d5abd9021304c1499e473ddaf6"))
	root3 := accountBase.StorageRoot
	value3, err2 := Verify(key3, db3, root3)

	if err2 != nil {
		t.Fatal(err2.Error())
	}

	t.Log(string(value3))
}
